#include <iostream>
#include <cmath>
#include <vector>
int main()
{
	std::ios_base::sync_with_stdio(0);
	std::cin.tie(0);

	/*
		1. x가 3으로 나누어 떨어지면 3으로 나눈다.
		2. x가 2로 나누어 떨어지면 2로 나눈다.
		3. 1을 뺀다.

		최소 몇 번의 연산이 필요한가
	*/
	int n;
	std::cin >> n;

	std::vector<int> dp(n + 1);
	dp[0] = dp[1] = 0;
	/*
		1, 2, 3은 모두 1번의 연산이면 된다
		4의경우 4 -> 3 -> 1 or 4 -> 2 -> 1인 2번의 연산이 필요하다.
		5의 경우 5 -> 4 -> 3 -> 1 or 5 -> 4 -> 2 -> 1 총 3번의 연산이 필요하다.
		6의 경우 6 -> 2 -> 1 or 6 -> 3 -> 1의 총 2번의 연산이 필요하다.
		7의 경우 7 -> 6 -> 2 -> 1 or 7 -> 6 -> 3 -> 1 총 3번읜 연산이 필요하다.
		8의 경우 8 -> 4 -> 3 -> 1 or 8 -> 4 -> 2 -> 1 총 3번의 연산이 필요하다.

		4 ~ 8의 경우를 살펴보면 N을 1로 만들기 위해 최소 횟수는 n - 1을 1로 만들기 위한
		최소횟수의 +1 또는 2나 3으로 나누어지면, 나누어지고 남은 몫의 경우의 연산 +1이다.
		두 가지 경우 중 더 작은 값을 선택해 주면 다음 최소횟수를 알 수 있다.

		4는 n - 1인 3을 1로 만들기 위한 최소 횟수 2 + 1인 3번이고 
		6의 경우 2나 3으로 나누어지기에 나누어지고 남은 몫인 
		3을 1로 만들기 위한 최소횟수인 1 + 1로 2번이다.
	*/
	// n이 제일 작은 1부터 연산의 최소 횟수를 저장해 필요한 횟수를 나중에 사용한다.
	for (int i = 2; i <= n; i++)
	{
		// 1. 1을 뺀다 (n - 1을 1로 만들기 위한 최소 횟수 + 1)
		dp[i] = dp[i - 1] + 1;

		// 2. 2로 나누어진다 (n/2을 1로 만들기 위한 최소 횟수 + 1과 n-1의 최소횟수 + 1 비교)
		if (i % 2 == 0)
			dp[i] = std::min(dp[i], dp[i / 2] + 1);

		// 3. 3으로 나누어진다 (n/3을 1로 만들기 위한 최소 횟수 + 1과 n-1의 최소횟수 + 1 비교)
		if (i % 3 == 0)
			dp[i] = std::min(dp[i], dp[i / 3] + 1);
	}

	std::cout << dp[n];

	return 0;
}