2의 보수(Two's Complement)

2의 보수는 비트 조작에서 매우 중요하다.
특히 음수 처리에 사용되는데 원리를 알아두어야 한다.

2의 보수 숫자 포맷

2의 보수는 컴퓨터가 음수를 저장하기 위해 일반적으로 취하는 방법 중 하나다.
원리 이해를 위해 4비트 레지스터 머신으로 가정하고 4비트로 숫자를 표현한다.

4비트 표현 범위는 0000~111로 총 16개다.
양수만 저장하면 0 ~ 15까지 16개를 저장할 수 있다.
C같은 언어에서는 unsigned 타입으로 선언하면 양수만 저장한다

문제는 음수도 저장해야 한다는 점인데 이를 위해 절반으로 쪼개서 음수 몫으로 할당하고
맨 앞 미트는 부호 비트(MSB, Most Significant Bit, 또는 최상위 비트)로 사용한다.

즉, 양수의 경우 0xxx를 사용하고 음수는 1xxx를 사용한다.
ex: 0 = 0000, 3 = 0011, 7 = 0111, -8 = 1000, -7 = 1001, -3 = 1101, -1 = 1111

2의 보수는 숫자를 -2^(n-1)에서 2^(n-1) - 1까지 표현할 수 있다.

이해하기 쉽게 n = 4를 사용했기에 -8에서 7까지가 표현범위다.
이렇게 2의 보수를 표현하려면 자릿수 제한 비트 연산에서 사용했던 bitmask를 사용해야된다.

MASK = 0xf = 0x1111
1 & MASK = 0x0001
7 & MASK = 0x0111
-8 & MASK = 0x1000
-7 & MASK = 0x1001
-1 & MASK = 0x1111

Masking을 해주면 2의 보수를 표현하는 것과 동일한 결과를 얻게 된다.

파이썬에서는 임의 정밀도(Arbitary-Precision)을 지원하기에 내부적으로 복잡한 구조로
2의 보수를 표현한다.
부호는 별도의 필드를 갖고 있고 비트 연산에 필요 시 2의 보수로 변환하는 작업을 한다.
음수를 보여줄 때는 양의 정수를 표현하는 방식과 동일하게 하고, 앞에 부호만 덧붙여서 보여준다.
즉, 2의 보수 값을 실제로 보여주지는 않지만 비트 연산 결과는 동일하기에 문제없다.


2의 보수 수학 연산

2의 보수라는 용어는 숫자 포맷으로 쓰일 떄와 수학 연산자로 쓰일때 각기 서로 다른
의미를 가지고 있어 헷갈릴 수 있다.

수학적 정의를 포함한 2의보수 수학 연산은 가산 역 연산(Additive Inverse Operation)이라
부를 수 있다.
쉽게 양수를 음수로, 음수를 양수로 바꾸는 작업을 의미한다.
방법은 비트 연산자 NOT을 한 후에 1을 더해 이뤄진다.

    1. '비트 연산자 NOT'은 2의 보수에서 1을 뺀 것
        (양수를 NOT 연산하면 1로 시작하는 음수 비트가 되는데,
        2의 보수 연산하면 숫자 자체는 커지지만 음수 이므로 -10이다
        ex: 7은 0000...0111으로 NOT 연산지 1111...1000이 된다.
        음수 이므로 2의 보수 연산하면 0000....10000이므로 8이 되고 따라서
        1111....1000은 -8이 된다.
        즉 NOT x = -x - 1이 된다.)


    2. '2의 보수 수학 연산'은 비트 연산자 NOT에서 1을 더한 것
        (즉 양수 -> 음수 변환 시에 계산하고 음수 비트가 
        어떤 수인지 알고 싶을 때 계산해 알아낸다.)

즉, 0111의 2의 보수 연산은 1000 + 1 = 1001이 된다.
1001의 비트 연산자 NOT은 0111 - 1 = 0110이다. (~1001로 표현하기도 한다.)

2의 보수 연산은 정확히 양수를 음수로, 음수를 양수로 만들어주는데 둘을 더하면
당연히 0이 되고, 이진수로 계산 시 0111 + 1001 = 10000로 자릿수 overflow가 발생하는데,
비트 연산이므로 초과한 자릿수는 무시하며 0000 = 0이된다.


비트 연산자 NOT

Bitwise NOT을 다시 보면 ~ 연사자인 비트 연산자 NOT은 기준 비트 내에서
정확히 1을 0으로, 0을 1로 바꿔준다.
4비트라 가정할 때 0111은 1000이며 2의 보수 포맷에서는 0111은 7, 1000은 -8로
NOT x = -x -1이 된다.

0x0101 ^ ~0x1100 = -0x1010

이 값이 0x0110이 아닌 이유는 입력값이 4비트 포맷이 아니라는 점 때문이다.
만약 4비트 머신이면 0x1100이 음수 -4여야 하는데 실제로는 양수 12로 가정했으므로
이미 overflow가 발생한 상태라 전제조건에 문제가 있는 것이다.

이 문제는 8비트 포맷 또는 더 큰 형태로 바꿔야 제대로 계산 가능하다.

0x00000101 ^ ~0x00001100 = -0x1010

8비트 포맷으로 적용해도 계산 결과는 동일하다.
이번에는 두 번째 값을 직접 먼저 계산한 결과를 두고 계산해본다.

0x00000101 ^ 0x11110011 = 0x11110110

여기서는 두 번째 값을 2의 보수로 직접 만들어 NOT 연산자부터 먼저 계산했다.
결과는 1111 0011이고 이 값과 XOR한 최종 결과는 1111 0110이다.
2의 보수이므로, 이 값은 -10이다.
-0x1010도 -10이므로 동일하다.

-10 = -0x1010 = 0x1111 0110

8비트가 아닌 16비트 또는 그 이상이라도 결과는 마찬가지다.
