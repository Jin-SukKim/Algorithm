비트 조작(bit operation) - 비트 조작은 많이 사용해보지 않아 낯설지만 중요하다.

원래 비트를 조작하는 것은 하드웨어와 관련이 깊다.
전기회로 스위치의 on/off를 이용한 스위칭 회로를 연구하며 true, false의 2개의
값으로 논리 연산을 설명하는 Boolean Algebra를 회로에 적용한 Logic Gate가 Base가 된다.

이를 이용한 논리 회로(Logic Circuit)는 모든 디지털 컴퓨터의 기본 개념이자 근간이다.

현대에는 비트 조작 기법은 하드웨어뿐만 아니라 다양하게 쓰인다.

가장 기본적인 Boolean Operation - NOT, AND, OR, XOR

AND, OR, NOT은 기본 Boolean 연산자로 연산들을 서로 결합하거나 조합해
다른 보조 연산을 만들어 낼 수 있다.
대표적으로 XOR이 보조 연산에 해당되며 (x AND NOT y) OR (NOT x AND y) 조합으로 생성한다.

하지만 XOR은 보조 연산을 뛰어 넘어 디지털 논리 게이트에서 매우 중요하다.

비트 연산자(Bitwise Operator) - &(AND), |(OR), ^(XOR), ~(NOT)

Boolean 연산자와 마찬가지로 비트 연산자도 동일하게 동작한다.
그런데 비트 연산자 NOT인 ~ (틸드)는 Bool 변수에 적용하면 True는 1로 간주되어 -2가 된다.
비트 연산자 NOT은 2의 보수에서 1을 뺸 값과 같기 때문이다.

따라서 십진수로 표현할 때는 NOT x = -x - 1 이 된다.
즉 NOT 1 = -1 -1이 되어 -2가 된다. (2의 보수에서 더 자세하게)
(컴퓨터는 2의 보수를 이용해 음수를 표현하기에 -x를 표현하기 위해서 ~x + 1 을 이용한다.)

비트 조작 퀴즈 - Arithmetic Operation

1: 0x0110 + 0x0010 = 0x01000
2: 0x0011 * 0x0101 = 0x1111
3: 0x1101 >> 2 = 0x0011 (오른쪽으로 2칸 시프팅) 1칸 시프팅 될때마다 2배씩 감소(절반씩 줄어드는 것)
4: 0x1101 << 2 = 0x110100 (왼쪽으로 2칸 시프팅) 1칸 시프팅 될때마다 2배씩 증가
5: 0x0101 ^ ~0x1100 = -0x1010
(5번 해설 - 0x1100 = 12. 비트 연산자 NOT의 결과는 십진수로 NOT x = -x - 1이고
2의 보수에서 1을 뺀 결과다. 즉, -12 - 1 = -13이된다.
-13을 2의 보수로 표현하면 11111...110011쯤 된다.
32비트 정수형이라면 앞에 28비트는 모두 1이다.
앞에 값은 0x0101이므로 이 값과 함께 XOR 연산을 한 결과는 111...110110이된다.
2의 보수로 표현하면 -10이 되고 -0x1010이 된다.)

자리수 제한 비트 연산

5번에서 기대했던 것처럼 0x1100이 0x0011로 바뀌게 하려면 별도의 작업이 필요하다.
자릿수 만큼의 최대값을 지닌 비트 마스트(bit mask)를 만들고, 그 갑소가 XOR을 통해
값을 만들어본다.
먼저 MASK 값인 0x1111과 XOR 결과는 0x0011이다.
0x1100 ^ 0x1111 = 0x0011
그렇다면 MASK과 XOR 결과를 처리하는 형태로 수정 가능하다.

MASK = 0x1111
0x0101 ^ (0x1100 ^ MASK) = 0x0110

C++에는 bitmask를 이용해 집합을 구현할 수 있다.

N 비트 정수 변수 = 0~N-1의 정수 원소를 가질 수 있는 집합
i가 집합에 속해있는지 여부 -> 2^i 를 나타내는 비트가 켜져있는지 확인

공집합과 꽉 찬 집합 :
    A = (1 << 20) - 1;
    상수 0: 공집합
    1 << 20 - 1 : 1뒤에 0이 20개에 -1을 하게되면 1이 20개 즉, 비트가 모두 켜진 수

원소 추가 :
    A |= (1 << k);
    OR연산으로 집합 A의 k번째 비트를 1로 바꾸는 것

원소 삭제 :
    A &= ~(1 << k);
    AND 연산으로 집합 A의 k번째 비트를 0로 바꾸는 것

원소의 포함 여부 확인:
    if (A & (1 << k))
    집합 A의 k번째 비트가 1인지 확인

원소의 토글(toggle) :
    A ^= (1 << k);
    k번째 비트가 1이면 0으로, 비트가 0이면 1로 XOR 연산

두 집합에 대한 연산 :
    A | B    -> A와 B의 합집합
    A & B    -> A와 B의 교집합
    A & (~B) -> A에서 B를 뺀 차집합
    A ^ B    -> A와 B중 하나에만 포함된 원소들의 집합 

집합의 크기 구하기 :
    int bitCount(int A){
        if(A == 0) return 0;
            return A%2 + bitCount(A / 2);
    }
    각 비트를 순회하면서 1인 비트를 직접 세는 방법

    [내장 명령어]
    gcc/g++ → __builtin_popcount(A) 
    visual C++ → __popcnt(A)
    Java → Integer.bitCount(A)

최소 원소 찾기 :
    int first = A & (-A);
    1인 비트가 있는 최하위 비트의 번호를 찾는다.
    비트위 위치를 구한 뒤 1을 왼쪽으로 shift하는 대신 음수와 &연산을 사용한다.
    컴퓨터가 음수를 표현하기 위해 2의 보수를 사용한다는 점을 이용한 것으로
    시스템은 -A를 표현하기 위해 A에 비트별 NOT 연산을 적용하고 1을 더한다.
    (2의 보수 : -A = ~A + 1)
    (ex: ~0x01101100 = -0x10010100, 2의 보수(two's complement) )

    A에서 가장 오른쪽(최하위)에 켜진(1) bit의 인덱스를 k라고 하면, k보다 오른쪽의
    모든 bit는 0이다.
    따라서 NOT 연산을 적용한 ~A는 k번째 bit는 0이고, 오른쪽의 모든 bit는 1이 된다.
    여기서 2의 보수에 따라 +1을 해주면 k번째 bit는 1되고 오른쪽 bit는 모두 0이된다.
    k번째 bit보다 왼쪽에 있는 bit는 아무런 변화가 없다.

    결국 -A와 A를 AND하면 k번째 bit만 켜진 상태로 남는다.

최소 원소 지우기 :
    A &= (A - 1);
    가장 오른쪽(최하위) bit를 지우기 위해 A-1과 AND 시키면 된다.
    A에서 1을 빼주면 가장 오른쪽에 있던 bit는 0이 되고 그보다 오른쪽에 있는
    모든 bit들이 1이 되기 때문이다.

모든 부분 집합 순회하기 :
    for (int subset = A ; subset ; subset = ((subset - 1) & A)){ }
    A의 모든 부분 집합을 탐색하는 방법이다.
    