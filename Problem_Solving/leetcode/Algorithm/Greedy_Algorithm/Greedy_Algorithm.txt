그리디 알고리즘(Greedy Algorithm)

그리디 알고리즘은 글로벌 최적을 찾기 위해 각 단계에서 로컬 최적의 선택을 하는
휴리스틱 문제 해결 알고리즘이다.

쉽게 바로 눈앞의 이익만을 쫓는 알고리즘을 말한다.
대부분은 뛰어난 결과를 도출하지 못하지만, 드물게 최적해를 보장한다.

이 알고리즘은 최젖ㄱ화 문제를 대상으로 한다.
최적해를 찾을 수 있으면 그것을 목표로 삼고, 찾기 어려운 경우 주어진 시간 내에
그런대로 괜찮은 해를 찾는 것을 목표로 삼는다.

물론 대부분의 문제들은 이런 로컬 최적해(Locally Optimum Solution)를 찾는
방법으로는 문제를 해결할 수 없지만 합리적인 시간 내에 최적에 가까운 답을 찾을 수
있는 알고리즘이다.

그리디 알고리즘이 잘 동작하는 문제들은 탐욕 선택 속성(Greedy Choice Property)을
갖고 있는 최적 부분 구조(Optimal Substructure)인 문제들이다.

탐욕 선택 속성이란 앞의 선택이 이후 선택에 영향을 주지 않는 것을 말한다.
즉, 선택을 다시 고려하지 않는다.

또한 최적 부분 구조란 문제의 최적 해결 방법이 부분 문제에 대한
최적 해결 방법으로 구성되는 경우를 말한다.(이 부분은 다이나믹 프로그래밍 파트를 봐야한다)

탐욕 선택 속성과 최적 부분 구조의 2가지 조건을 만족하면 최적해를 찾을 수 있다.
하지만 그렇지 않더라도 그리디 알고리즘은 정답의 근사치를 찾는 용도로 활용 가능하며
대부분의 경우 계산 속도가 빠르므로 매우 실용적이다.

그리디 알고리즘이 잘 동작하는 예는 많다.
최단 경로 문제를 풀이하는 Dijkstra 알고리즘은 대표적은 그리디 알고리즘의 예로
최적해를 찾을 수 있따.

또한 압축 알고리즘인 Huffman Coding 알고리즘은 허프만 트리를 빌드할 때 그리디
알고리즘ㅇ르 사용하며 최적해가 보장된다.

머신러닝 분야에서는 의사결정 트리(Decision Tree)알고리즘으로 유명한 ID3 알고리즘이
그리디 알고리즘이다.
항상 그때 그때 최선의 답을 찾아 트리를 빌드해 나간다.
이 경우 쵲거에 가까운 답을 찾을 수 있지만, 반드시 최적해를 찾는 것이 아닌 근사치를 찾는다.

그리디 알고리즘은 최적 부분 구조 문제를 푼다는 점에서 흔히 다이나믹 프로그래밍과
비교되는데, 서로 풀 수 있는 문제의 성격이 다르며, 알고리즘의 접근 방식도 다르다.

다이나믹 프로그래밍은 하위 문제에 대한 최적의 솔류선을 찾은 다음, 이 결과들을 결합한
정보에 입각해 전역 최적 솔루션(Glovally Optimum Solution)에 대한 선택을 한다.

그리디 알고리즘은 각 단계마다 로컬 최적해를 찾는 문제로 접근해 문제를 더 작게
줄여나가는 형태로, 서로 반대 방향으로 접근하는 구조를 띤다.


배낭 문제(Knapsack Problem)

배낭문제는 조합 최적화(Combinatorial Optimization) 분야의 매우 유명한 문제로,
배낭에 담을 수 있는 무게의 최댓값이 정해져 있고 각각 짐의 가치와 무게가 있는
짐들을 배낭에 넣을 때 가치의 합이 최대가 되도록 짐을 고르는 방법을 찾는 문제다.

배낭 문제는 짐을 쪼갤 수 있는 경우인 분할 가능 배낭 문제(Fractional Knapsack Problem)
,그리디 알고리즘으로 해결,와 짐을 쪼갤 수 없는 경우닝 배낭 문제(다이나믹 프로그래밍)
으로 나뉜다.

짐을 쪼갤 수 있는 배낭 문제 -> Knapsack_Problem.txt


동전 바꾸기 문제