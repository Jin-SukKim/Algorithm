다이나믹 프로그래밍(Dynamic Programming)

다이나믹 프로그래밍 알고리즘은 응용수학자 리차드 벨만이 고안한 알고리즘으로,
문제를 각각의 작은 문제로 나누어 해결한 결과를 저장해뒀다가 나중에 큰 문제의 결과와
합하여 풀이하는 알고리즘이다.

이 알고리즘을 이용하면, 문제의 최적 해결 방법이 부분 문제에 대한 최적 해결 방법으로
구성되는 경우의 문제, 즉 최적 부분 구조(Optimal Substructure)를 갖고 있는 문제를
풀이할 수 있다.

최적 부분 구조를 푸는 또 다른 알고리즘으로는 그리디 알고리즘이 있다.
비슷한 유형의 문제를 풀이한다는 점에서 비교 대상이 된다.

그리디 알고리즘은 항상 그 순간에 최적이라고생각되는 것을 선택하면서 풀이해 나가고,
다이나믹 프로그래밍은 중복된 하위 문제들(Overlapping Subproblem)의 결과를
저장해뒀다가 풀이해 나간다는 차이가 있다.

중요한 점은 '중복된' 문제들이란 점이며, 중복되지 않는 문제들은 다이나믹 프로그래밍으로
풀지 않는다.
대표적으로 병합 정렬과 퀵 정렬 등이 있으며, 이들은 모두 분할 정복 알고리즘으로 분류한다.

대부분의 재귀 알고리즘은 최적 부분 구조 문제를 풀 수 있다.
이 중에서도 병합 정렬, 퀵 정렬과 같은 분할 정복 알고리즘은 '중복된 하위 문제들'을
푸는 것이 아니기 때문에 다이나믹 프로그래밍으로 분류하지 않는다.
배낭 문제 중 분할 가능 배낭 문제(Fractional Knapsack Problem)는 '탐욕 선택 속석'이
있기 때문에 그리디 알고리즘으로 풀이할 수 있다.

알고리즘과 풀이 가능한 문제들의 특징

1. 다이나믹 프로그래밍 :
    - 최적 부분 구조(Optimal Substructure)
    - 중복된 하위 문제들(Overlapping Subproblem)
    ex: 0-1 배낭 문제, 피보나치 수열, Dijkstra 알고리즘

2. 그리디 알고리즘 :
    - 최적 부분 구조(Optimal Substructure)
    - 탐욕 서택 속성(Greedy Choice Property)
    ex: 분할 가능 배낭 문제, Dijkstra 알고리즘

3. 분할 정복 :
    - 최적 부분 구조(Optimal Substructure)
    ex: 병합 정렬, 퀵 정렬

Dijkstra 알고리즘은 다이나믹 프로그래밍과 그리디 알고리즘 둘 다 해당하는 경우인데,
BFS(너비 우선 탐색) 시 항상 최단 경로를 찾고 탐욕 선택 속성을 같는 그리디 알고리즘이면서,
이미 계산한 경로는 저장해두었다가 활용하며 중복된 하위 문제들을 푸는 다이나믹 알고리즘이기도 하다.


최적 부분 구조(Optimal Substructure)

최적 부분 구조에 대한 예로는 서울에서 부산까지 가는 최단 경로를 찾는 예가 있다.

만약 서울에서 대구까지 가는 경로가 3가지 있으며, 부산까지 마찬가지로 3가지 경로가 있다.
서울에서 부산까지 가는 최단 경로는 200km + 80km = 280km이다.
이 경로는 서울에서 대구까지 가는 최단 경로(200km)와 대구에서 부산까지 가는 
최단 경로(80km)로 구성된다.

즉 서울에서 부산까지 가는 최단 경로는 각각의 부분 문제인 1) 서울에서 대구까지 가는
최단 경로 문제와 2) 대구에서 부산까지 가는 최단 경로 문제의 해결 방법의 합이다.

따라서 문제의 최적 해결 방법은 부분 문제에 대한 최적 해결 방법으로 구성된다.

이런 구조를 최적 부분 구조라 하며, 분할 정복으로 풀 수 있다.
만약 서울에서 부산까지 직통 도로가 개통되었다면 더 이상 두 알고리즘으로 풀 수 없다.


중복된 하위 문제들

다이나믹 알고리즘으로 풀 수 있는 문제들과 다른 문제들의 결정적인 차이는 중복된
하위 문제들을 갖는다는 점이다.
ex: 피보나치 수열의 경우 f(x) = f(x-1) + f(x-2)의 동일한 하위 문제들이 발생한다.
그래서 중복 문제가 발생하지 않는 병합 정렬은 분할 정복으로 분류되지만,
피보나치 수열은 다이나믹 프로그래밍인 이유다.


다이나믹 프로그래밍 방법론

방법론은 방식에 따라 크게 상향식과 하향식으로 나뉜다.
일반적으로 상향식을 타뷸레이션, 하향식을 메모이제이션이라고 구분해 부르기도 한다.

1. 상향식(Bottom-Up) :
    더 작은 하위 문제부터 살펴본 다음, 작은 문제의 정답을 이용해 큰 문제의 정답을 풀어나간다.
    타뷸레이션(Tabulation)이라 부르며, 일반적으로 이 방식만을 다이나믹 프로그래밍으로 지칭하기도 한다.

2. 하향식(Top-Down)  :
    하위 문제에 대한 정답을 계산했는지 확인해가며 문제를 자연스러운 방식으로 풀어나간다.
    이 방식을 특별히 메모이제이션(Memoization)이라 지칭한다.


피보나치 수열로 상향식과 하향식 구분(fib.txt)

상향식 방법론으로 작은 하위 문제부터 차례대로 정답을 풀어나가며 큰 문제의 정답을 만든다.
데이터를 테이블 형태로 만들면서(Tabulation) 문제를 풀이한다고 하여 타뷸레이션 방식이라 한다.

하향식 방법론은 하위 문제에 대한 정답을 계산했는지 확인해가며 문제를 자연스럽게
재귀로 풀어나간다.
기존 재귀 풀이와 거의 동일하면서도 이미 풀어봤는지 확인하여 재활용하는 효율적인 방식으로,
메모이제이션(Memoization) 방식이라고 부른다.


0-1 배낭 문제(Knapsack.txt)

또 다른 다이나믹 프로그래밍의 대표적인 문제로 그리디 알고리즘으로 풀었던
분할 가능 배낭 문제와 비슷하나 탐욕 선택 속성이 없다.

이번에는 짐을 쪼갤 수 없는 0-1 배낭 문제다.
중복된 하위 문제들 속성을 갖고 있으므로 다이나믹 프로그래밍으로 풀 수 있다.

단가 순으로 그리디하게 배치해서 풀었던 분할 가능 배낭 문제와 달리
0-1 배낭 문제는 짐을 쪼갤 수 없다.
이 경우 모든 경우의 수를 계산해야 하며, 이렇게 모든 경우의 수를 계산하는 문제에서
다이나믹 프로그래밍은 위력을 발휘한다.


대표적인 2가지 다이나믹 프로그래밍 문제인 피보나치 수와 배낭 문제를 살펴봤다.
다이나믹 프로그래밍 문제는 가장 난이도가 높은 문제들에 해당된다.
