단가 순으로 그리디하게 배치해서 풀었던 분할 가능 배낭 문제와 달리
0-1 배낭 문제는 짐을 쪼갤 수 없다.
이 경우 모든 경우의 수를 계산해야 하며, 이렇게 모든 경우의 수를 계산하는 문제에서
다이나믹 프로그래밍은 위력을 발휘한다.

먼저, 입력값으로 짐을 정의하고 풀이 함수를 호출한다.

cargo = [[4, 12], [2, 1], [10, 4], [1, 1], [2, 2]]
r = zero_one_knapsack(cargo)

이 함수는 다음과 같다.
def zero_one_knapsack(cargo):
    capacity = 15
    pack = []
    ...

pack이라는 변수에 6x16 행렬 형태의 중간 결과 테이블이 생성될 것이다.
즉, 이 테이블을 글자 그대로 Tabulation하는 다이나믹 프로그래밍 풀이가 된다.

테이블 크기의 기준은 짐의 최대 개수 + 1, 배낭의 최대 용량 + 1 이렇게 6x16이며,
이 테이블 각각의 셀에는 그 위치까지의 짐의 개수와 배낭의 용량에 따른 최댓값이 담기게 된다.

def zero_one_knapsack(cargo):
    capacity = 15
    pack = []

    # 물건 개수 
    for i in range(len(cargo) + 1):
        pack.append([])
        # 배낭의 최대 용량 (짐의 개수와 배낭의 용량에 따른 최댓값)
        for c in range(capacity + 1):
            # 시작엔 아무것도 안 담았으므로 0
            if i == 0 or c == 0:
                pack[i].append(0)
            # 물건 i의 무게가 배낭 용량을 초가하지 않으면 최댓값을 담는다.
            elif cargo[i - 1][1] <= c:
                pack[i].append(
                    max(
                        cargo[i - 1][0] + pack[i - 1][c - cargo[i - 1][1]],
                        pack[i - 1][c]
                    )
                )
            # 물건 i의 무게가 배낭 용량을 초과하면 물건 i - 1까지만 담는다.
            else:
                pack[i].append(pack[i - 1][c])

    return pack[-1][-1]

실행 결과로는 6x16의 행렬 형태의 표가 생성된다.
세로 축은 짐의 개수, 가로축은 배낭의 용량이며 각각의 셀은 그 위치까지의 짐의 개수와
배낭의 용량에 따른 최댓값이다.

즉 짐이 4개가 잇으면 ($4, 12kg), (2, 1), (10, 4), (1, 1)일 것이고, 
배낭의 용량이 4라면 4kg인 $10짜리 짐 하나를 담는 게 가장 이익이다.

결국 4x4 위치의 최댓값은 10이다.
용량이 5라면 1kg인 $2를 추가해 12가 될 수 있따.

용량이 15인 배낭의 최댓값은 15이며, 최악의 경우 O(2^n)의 계산이 필요한 0-1 배낭 문제를
여기서는 Tabulation방식으로 O(nW)(n = 짐의 개수, W = 배낭의 용량)에 풀이가 된다.