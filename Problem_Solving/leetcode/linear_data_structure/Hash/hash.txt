
Hash Table(Hash map) : 키를 값에 매핑할 수 있는 구조인, 연관 배열 추상 자료형(ADT)를 구현하는 자료구조다
특징 - 대부분의 연산이 분할 상환 분석에 따른 시간 복잡도가 O(1)이다.

Hash 함수란 크기 데이터를 고정 크기 값으로 매핑하는데 사용할 수 있는 함수다.
해시 테이블은 indexing을 위해 해시 함수를 사용한다(Hashing)

Hashing은 최적의 검색이 필요한 분야에 사용되며, Symbol table 등 자료구조를 구현하기도 한다.
이외에 Checksum, 손실 압축, Randomization Function, 암호등에도 사용된다.

해시 함수들의 특징
- 해시 함수 값 충돌의 최소화
- 쉽고 빠른 연산
- 해시 테이블 전체에 해시 값이 균일하게 분포
- 사용할 키의 모든 정보를 이요하여 해싱
- 해시 테이블 사용 효율이 높을 것

충돌은 과연 얼마나 많이 발생하나? (생일 문제, Birthday Problem) - 충돌은 쉽게 일어나 최소화하는 일이 매우 중요하다

충돌이 왜 일어날 수밖에 없나? (비둘기집 원리,Pigeonhole Principle) - 충돌의 원리

여러 번 충돌한다는 것은 추가 연산을 필요로 하기에 가급적 충돌을 최소화해줘야 한다.

로드 팩터(Load Factor) - 해시 테이블에 저장된 데이터 개수 n을 버킷의 개수 k로 나눈것이다.

    load_factor = n / k

로드 팩터 비율에 따라 해시 함수를 재작성해야 해야 될지 또는 해시 테이블의 크기를 조정할지를 결정한다.
또한 해시 함수가 키들을 잘 분산해 주는지의 효율성 측정에도 사용된다. (로드 팩터 증가 = 성능 감소)
(java 10에선 0.75를 default로 정하며 '시간과 공간 비용의 적절한 절충안'이라 얘기한다.)

여러 해싱 기법 중 가장 단순하면서 널리 쓰이는 정수형 해싱 기법인 모듈로 연산을 이용한
나눗셈 방식(Modulo-Division Method)를 살펴본다.

    h(x) = x mod m, 
    x = input(간단한 규칙을 통해 만든 랜덤한 상태의 키), 
    m = size of hash table(2의 멱수에 가깝지 않은 소수가 좋다)
    (2의 멱수라는 것은, 2^k으로 표현되는 자연수)

    ex) 조슈아 블로크는 자바 설계시 값 x를 다항식의 결과로 정의했다.
        P(x) = s[0] * x^(n-1) + s[1] * x^(n-2) + ... + s[n-1]
        여기서 x는 31로 하는 거듭제곱 P(31)의 연산으로 정의했다고 밝혔다.

    // hash : 문자열 s에 대한 해시 값 구성(C 언어)
    unsigned hash(char *s) {
        unsigned hashval;

        for (hashval = 0; s* != '\0'; s++)
            hashval = *s + 31 * hashval;
        
        retrun hashval % HASHSIZE;
    }
    // 1997년 당시 RISC(과거 CPU, 현재 스마트폰의 ARM CPU의 기본 구조) 머신에서 가장 저렴한 계산 비용
    // 이정도의 간단한 형태가 성능과 충돌의 적절한 합의점이었으며 31은 메르센 소수(Mersenne Prime)으로 수학적으로 나쁘지 않은 선택이다.

    // 자바JDK
    hashCode = 31 * hashCode + (e == null? 0 : e.hashCode());

해시 함수는 매우 중요한 역할인데 몇년 전 구글이 딥러닝으로 학습한 모델을 적용해
충돌을 최소화하는 논문도 발표했었다.

충돌(Collision)

아무리 좋은 해시 함수라도 충돌(Collision)은 발생한다.
충돌이 발생하는 경우 처리하는 방법

1. 개별 체이닝(Separate Chaining)
    충돌 발생시 연결 리스트로 연결(link)하는 방식이다.
    충돌이 발생한 두 아이템은 item1 -> item2와 같이 Linked-List로 연결한다.

    기본적인 자료구조와 임의로정한 간단한 알고리즘으로 인해 인기가 높다.
    해시 테이블구조의 원형이며 가장 전통적인 방법이다.

    원리
    1) 키의 해시 값을 계산한다.
    2) 해시 값을 이용해 배열의 인덱스를 구한다.
    3) 같은 인덱스가 있다면 연결 리스트로 연결한다

    잘 구현한 경우 탐색은 O(1)이지만 최악의 경우(모든 해시 충돌)엔 O(n)이다.
    자바의 경우 데이터의 개수가 많아지면 레드-블랙 트리(자가 균형 이진 탐색 트리)에 저장하는 형태로 병행해 Linked-List 구조를 좀 더최적화했다.

2. 오픈 어드레싱(Open Addressing)
    충돌 발생 시 탐사를 통해 빈 공간을 찾아나서는 방식이다.
    무한정 저장할 수 있는 체이닝 방식과 달리, 이 방식은 전체 슬롯의 개수 이상은 저장할 수 없다.

    충돌 발생 시 테이블 공간 내에서 탐사(Probing)를 통해 빈 공간을 찾아 해결하며,
    이때문에 개별 체이닝과 달리, 모든 원소가 반드시 자신의 해시값과 일치하는 주소에 저장된다는 보장은 없다.

    가장 간단한 방식인 선형 탐사(Linear Probing) 방식은 충돌 발생 시 해당 위치부터 순차적으로 탐사한다.
    특정 위치가 선점되어 있으면 그 가까운 빈 위치를 발견해 삽입한다.
    (item1이 위치 2에 들어가면 충돌한 item2는 다음 빈 위치인 위치 3에 들어가는 식이다.)

    구현이 간단하며 의외로 전체적인 성능이 좋다.

    선형 탐사의 문제점은 데이터들이고르게 분포되지 않고 뭉쳐 연속된 데이터 그룹이 생기는 현상이 있을 수 있다.
    이 현상을 클러스터링(Clustering)이라 하는데, 이게 커지면 인근 클러스터들과 서로 합쳐지는 일이 발생한다.
    그러면 해시 테이블의 특정 위치에 데이터가 몰려 다른 위치엔 데이터가 상대적으로 거의 없을 수 있다.(탐사 시간 증가 = 효율성 감소)

    또한 버킷 사이즈보다 큰경우 삽입할 수 없어 일정 이상 채워지면(로드 팩터 비율을 넘어서면) Growth Factor의 비율에따라
    더 큰 크기의 버킷을 생성해 새롭게 복사하는 Rehashing 작업이일어난다.

언어별 해시 테이블 구현 방식

파이썬:
    리스트와 함께 파이썬에서 가장 흔하게 쓰이는 딕셔너리는 해시 테이블로 구현되 있다.
    파이썬의 해시 테이블은 충돌 시오픈 어드레싱 방식을 사용한다.
    CPython 구현의 주석 : 체이닝 시 malloc으로 메모리를 할당하는 오버레드가 높아 오픈 어드레싱을 택했다.

    연결 리스트를 만들기 위해선 추가 메모리 할당이 필요하고, 이는 상대적으로 느린 작업이기에 채택하지 않았다고 한다.


오픈 어드레싱의 한 방식인 선형 탐사 방식은 일반적으로 체이닝에 비해 성능이더 좋다.
하지만 슬롯의 80% 이상이 차게 되면 급격한 성능 저하가일어나며,
체이닝과 달리 전체 슬롯의 전체 개수 이상, 즉 Load Factor 1 이상은 저장할수없다.

최근의 루비나 파이썬 같은 Modern 언러들은 오픈 어드레싱 방식을 택해 성능을 높이는 대신,
Load Factor를 작게 잡아 성능 저하 문제를 해결한다.

파이썬의로드 팩터는 0.66이며 루비는 0.5다.

C++(GCC libstdc++) : 개별 체이닝
자바 : 개별 체이닝
고(Go) : 개별 체이닝
루비 : 오픈 어드레싱
파이썬 : 오픈 어드레싱