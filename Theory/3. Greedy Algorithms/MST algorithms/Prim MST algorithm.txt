/*
    Prim MST algorithm
        - 노드 선택을 기반으로 그래프를 그린다
        - 시작 노드에서부터 최소 간선으로 연결된 노드를 선택해 연결한다
*/

ex) 
// A C++ program for Prim's Minimum 
// Spanning Tree (MST) algorithm. The program is 
// for adjacency matrix representation of the graph 
#include <bits/stdc++.h> 
using namespace std; 

// Number of vertices in the graph 
#define V 5 

// A utility function to find the vertex with 
// minimum key value, from the set of vertices 
// not yet included in MST 
int minKey(int key[], bool mstSet[]) 
{ 
	// Initialize min value 
	int min = INT_MAX, min_index; 

	for (int v = 0; v < V; v++) 
		if (mstSet[v] == false && key[v] < min) 
			min = key[v], min_index = v; 

	return min_index; 
} 

// A utility function to print the 
// constructed MST stored in parent[] 
void printMST(int parent[], int graph[V][V]) 
{ 
	cout<<"Edge \tWeight\n"; 
	for (int i = 1; i < V; i++) 
		cout<<parent[i]<<" - "<<i<<" \t"<<graph[i][parent[i]]<<" \n"; 
} 

// Function to construct and print MST for 
// a graph represented using adjacency 
// matrix representation 
void primMST(int graph[V][V]) 
{ 
	// Array to store constructed MST 
	int parent[V]; 
	
	// Key values used to pick minimum weight edge in cut 
	int key[V]; 
	
	// To represent set of vertices not yet included in MST 
	bool mstSet[V]; 

	// Initialize all keys as INFINITE 
	for (int i = 0; i < V; i++) 
		key[i] = INT_MAX, mstSet[i] = false; 

	// Always include first 1st vertex in MST. 
	// Make key 0 so that this vertex is picked as first vertex. 
	key[0] = 0; 
	parent[0] = -1; // First node is always root of MST 

	// The MST will have V vertices 
	for (int count = 0; count < V - 1; count++) 
	{ 
		// Pick the minimum key vertex from the 
		// set of vertices not yet included in MST 
		int u = minKey(key, mstSet); 

		// Add the picked vertex to the MST Set 
		mstSet[u] = true; 

		// Update key value and parent index of 
		// the adjacent vertices of the picked vertex. 
		// Consider only those vertices which are not 
		// yet included in MST 
		for (int v = 0; v < V; v++) 

			// graph[u][v] is non zero only for adjacent vertices of m 
			// mstSet[v] is false for vertices not yet included in MST 
			// Update the key only if graph[u][v] is smaller than key[v] 
			if (graph[u][v] && mstSet[v] == false && graph[u][v] < key[v]) 
				parent[v] = u, key[v] = graph[u][v]; 
	} 

	// print the constructed MST 
	printMST(parent, graph); 
} 

// Driver code 
int main() 
{ 
	/* Let us create the following graph 
		2 3 
	(0)--(1)--(2) 
	| / \ | 
	6| 8/ \5 |7 
	| / \ | 
	(3)-------(4) 
			9	 */
	int graph[V][V] = { { 0, 2, 0, 6, 0 }, 
						{ 2, 0, 3, 8, 5 }, 
						{ 0, 3, 0, 0, 7 }, 
						{ 6, 8, 0, 0, 9 }, 
						{ 0, 5, 7, 9, 0 } }; 

	// Print the solution 
	primMST(graph); 

	return 0; 
} 

// This code is contributed by rathbhupendra 

ex2)
/*************************************************
 ** Prim의 최소 비용 신장 트리 프로그램
*************************************************/
 
#include <stdio.h>
#define TRUE 1
#define FALSE 0
 
#define MAX_VERTICES 7  // 신장트리의 정점 개수
#define INF 1000L // 경로가 없는 INFINITE를 표현하기 위해 정의된 상수 INF
 
int weight[MAX_VERTICES][MAX_VERTICES] = {// 신장트리의 거리와 모양을 배열로 표현, INF는 바로갈 수 있는 경로가 없음을 뜻한다.
  {0,29,INF,INF,INF,10,INF},
  {29,0,16,INF,INF,INF,15},
  {INF,16,0,12,INF,INF,INF},
  {INF,INF,12,0,22,INF,18},
  {INF,INF,INF,22,0,27,25},
  {10,INF,INF,INF,27,0,INF},
  {INF,15,INF,18,25,INF,0}
};
 
int selected[MAX_VERTICES]; // 선택된 정점의 정보를 담을 배열, 선택이 됐는지 안됐는지를 표시한다.
int dist[MAX_VERTICES]; // 최소의 거리 정보만을 담는 배열, 새로운 최소거리가 나올 때마다 갱신된다.
 
// 최소 dist[v]값을 갖는 정점을 반환
int get_min_vertex(int n)
{
  int v, i; // 정점의 정보를 저장할 변수 v, 반복문을 위한 변수 i
   
  for (i = 0; i < n; i++)
  {
    if (selected[i] == FALSE) {
      v = i;  // 아직 선택되지 않은 정점의 번호를 v에 저장, 각 함수 실행별 0부터 n - 1까지 차례대로 저장된다.
      break;
    }
  }
 
  // 위에서 선택된 정점이 과연 최소거리를 지니고 있는 정점인지를 확인한다.
  for (i = 0; i < n; i++)
  {
    // 선택되지 않은 정점들을 순회하면서 최소거리를 가진 정점을 찾아낸다.
    if (selected[i] = FALSE && (dist[i] < dist[v]))
      v = i;  // 더 적은 거리가 존재한다면 해당 정점을 저장한다.
  }
 
  return(v);  // 최소의 거리를 갖는 정점이 선택됐으므로 정점 번호를 리턴한다.
}
 
// Prim, s는 시작 정점
void prim(int s, int n)
{
  int i, u, v;
 
  for (u = 0; u < n; u++)  // dist배열과 selected배열의 정보를 초기화
  {
    dist[u] = INF;
    selected[u] = FALSE;
  }
 
  dist[s] = 0;  // 시작정점과 시작정점간의 거리는 0이다. 자기자신을 순환하는 경로는 없다고 가정한다.
   
  for (i = 0; i < n; i++)
  {
    // 리턴된 정점 번호를 u에 저장한다. u는 최소거리를 가지는 정점. 손으로 썻을 때 선택하는 효과를 가져온다.
    u = get_min_vertex(n);
    selected[u] = TRUE; // 최소거리를 갖는 정점의 정보(u)를 알아냈으니 해당 정점을 선택했다고 표시한다.
 
    // 만약 경로가 없다면 함수를 종료한다. 정상적인 신장트리의 정보가 들어왔다면 실행될 일은 없을 것이다.
    if (dist[u] == INF) return;
     
    printf("%d ", u); // 방문한 정점(u)을 출력한다.
 
    for (v = 0; v < n; v++)  // 이 과정은 우리가 새롭게 발견한 정보를 저장하는 과정이다.
    // 직접적인 경로가 발견되어 INF 에서 상수거리로 바뀌는 과정과
    // 기존의 상수거리보다 더 짧은 거리가 발견되 그 정보를 갱신하는 과정이 포함되어 있다.
    {
      // 선택된 u 정점을 기준으로 정점(u)과 연결되어 있는 정점까지의 거리를 각각 비교한다.
      if (weight[u][v] != INF)  // 정점 u와 연결이 되어있고
      {
        // 아직 선택되지 않았으며 해당 변(weight[u][v])의 길이가 기존의 dist[v] 값보다 작다면
        if (selected[v] == FALSE && weight[u][v] < dist[v])
          dist[v] = weight[u][v]; // dist[v]의 값을 갱신해준다.
 
        // 새롭게 발견되는 정점들이 초반에 저장될 수 있는 건 INF를 1000으로 설정해줬기 때문이다.
        // 우리가 만든 그래프의 경로값들은 전부 100이하의 값이기 때문에 새롭게 발견되는 정점이 있다면
        // 우선 등록되고 그 후 더 짧은 거리가 등장하면 갱신되는 형태로 이 프로그램은 작동한다.
      }
    }
  }
}
 
void main()
{
  prim(0, MAX_VERTICES);  // 정점 개수가 7개인 그래프에서 0번 정점을 출발하여 얻을 수 있는 최소비용신장트리를 찾아라.
}
 
/*************************************************
 ** End Line
*************************************************/


출처: https://mattlee.tistory.com/46 [waca's field]